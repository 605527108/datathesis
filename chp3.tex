\chapter{用户上网数据采集与处理}
本章主要介绍用户上网如何留下信息，如何将上网信息转变为推荐系统所需要的训练集。其中包括了以下内容：网络流量信息采集、打开URL后发生了什么、如何给原数据库中没有的url分类、如何格式化、存储
\section{网络信息结构及内容}
互联网用户通过各类软件发送、接受信息。对于不同的软件，有不同的信息发送、接受格式,称作协议。以大多数网络浏览器使用的基本HTTP协议来说，其请求的头部有以下常用的信息 \\
\begin{center}
\tablecaption{HTTP协议请求头部常用的信息}
\begin{tabular}{l|p{10cm}}
 \hline
头部名称 & 描述 \\ \hline
Accept & Content-Types that are acceptable for the response \\ \hline
Content-Type & The MIME type of the body of the request (used with POST and PUT requests) \\ \hline
Date & The date and time that the message was sent \\ \hline
Host & The domain name of the server (for virtual hosting), and the TCP port number on which the server is listening. The port number may be omitted if the port is the standard port for the service requested \\ \hline
Referer & This is the address of the previous web page from which a link to the currently requested page was followed \\ \hline
User-Agent & The user agent string of the user agent \\
\hline
\end{tabular}
\end{center}
根据以上HTTP请求头部我们可以获得用户请求网站URL，请求时间，使用浏览器类型信息。
当然对于纪录了所有网络流量包的情况，我们甚至可以解压信息包，获得网页信息。对于使用其他协议的软件来说，只要按照该协议的约定，也能正确解压信息包，获取其中内容。

\section{网络流量信息采集与处理}
\usetikzlibrary{backgrounds,calc,shadings,shapes.arrows,shapes.symbols,shadows}
\definecolor{switch}{HTML}{006996}
\makeatletter
\pgfkeys{/pgf/.cd,
  parallelepiped offset x/.initial=2mm,
  parallelepiped offset y/.initial=2mm
}
\pgfdeclareshape{parallelepiped}
{
  \inheritsavedanchors[from=rectangle] % this is nearly a rectangle
  \inheritanchorborder[from=rectangle]
  \inheritanchor[from=rectangle]{north}
  \inheritanchor[from=rectangle]{north west}
  \inheritanchor[from=rectangle]{north east}
  \inheritanchor[from=rectangle]{center}
  \inheritanchor[from=rectangle]{west}
  \inheritanchor[from=rectangle]{east}
  \inheritanchor[from=rectangle]{mid}
  \inheritanchor[from=rectangle]{mid west}
  \inheritanchor[from=rectangle]{mid east}
  \inheritanchor[from=rectangle]{base}
  \inheritanchor[from=rectangle]{base west}
  \inheritanchor[from=rectangle]{base east}
  \inheritanchor[from=rectangle]{south}
  \inheritanchor[from=rectangle]{south west}
  \inheritanchor[from=rectangle]{south east}
  \backgroundpath{
    % store lower right in xa/ya and upper right in xb/yb
    \southwest \pgf@xa=\pgf@x \pgf@ya=\pgf@y
    \northeast \pgf@xb=\pgf@x \pgf@yb=\pgf@y
    \pgfmathsetlength\pgfutil@tempdima{\pgfkeysvalueof{/pgf/parallelepiped
      offset x}}
    \pgfmathsetlength\pgfutil@tempdimb{\pgfkeysvalueof{/pgf/parallelepiped
      offset y}}
    \def\ppd@offset{\pgfpoint{\pgfutil@tempdima}{\pgfutil@tempdimb}}
    \pgfpathmoveto{\pgfqpoint{\pgf@xa}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
    \pgfpathlineto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
    \pgfpathlineto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathclose
    \pgfpathmoveto{\pgfqpoint{\pgf@xb}{\pgf@ya}}
    \pgfpathlineto{\pgfpointadd{\pgfpoint{\pgf@xb}{\pgf@ya}}{\ppd@offset}}
    \pgfpathlineto{\pgfpointadd{\pgfpoint{\pgf@xb}{\pgf@yb}}{\ppd@offset}}
    \pgfpathlineto{\pgfpointadd{\pgfpoint{\pgf@xa}{\pgf@yb}}{\ppd@offset}}
    \pgfpathlineto{\pgfqpoint{\pgf@xa}{\pgf@yb}}
    \pgfpathmoveto{\pgfqpoint{\pgf@xb}{\pgf@yb}}
    \pgfpathlineto{\pgfpointadd{\pgfpoint{\pgf@xb}{\pgf@yb}}{\ppd@offset}}
  }
}
\makeatother

\tikzset{l3 switch/.style={
    parallelepiped,fill=switch, draw=white,
    minimum width=0.75cm,
    minimum height=0.75cm,
    parallelepiped offset x=1.75mm,
    parallelepiped offset y=1.25mm,
    path picture={
      \node[fill=white,
        circle,
        minimum size=6pt,
        inner sep=0pt,
        append after command={
          \pgfextra{
            \foreach \angle in {0,45,...,360}
            \draw[-latex,fill=white] (\tikzlastnode.\angle)--++(\angle:2.25mm);
          }
        }
      ] 
       at ([xshift=-0.75mm,yshift=-0.5mm]path picture bounding box.center){};
    }
  },
  ports/.style={
    line width=0.3pt,
    top color=gray!20,
    bottom color=gray!80
  },
  rack switch/.style={
    parallelepiped,fill=white, draw,
    minimum width=1.25cm,
    minimum height=0.25cm,
    parallelepiped offset x=2mm,
    parallelepiped offset y=1.25mm,
    xscale=-1,
    path picture={
      \draw[top color=gray!5,bottom color=gray!40]
      (path picture bounding box.south west) rectangle 
      (path picture bounding box.north east);
      \coordinate (A-west) at ([xshift=-0.2cm]path picture bounding box.west);
      \coordinate (A-center) at ($(path picture bounding box.center)!0!(path
        picture bounding box.south)$);
      \foreach \x in {0.275,0.525,0.775}{
        \draw[ports]([yshift=-0.05cm]$(A-west)!\x!(A-center)$)
          rectangle +(0.1,0.05);
        \draw[ports]([yshift=-0.125cm]$(A-west)!\x!(A-center)$)
          rectangle +(0.1,0.05);
       } 
      \coordinate (A-east) at (path picture bounding box.east);
      \foreach \x in {0.085,0.21,0.335,0.455,0.635,0.755,0.875,1}{
        \draw[ports]([yshift=-0.1125cm]$(A-east)!\x!(A-center)$)
          rectangle +(0.05,0.1);       
      }
    }
  },
  server/.style={
    parallelepiped,
    fill=white, draw,
    minimum width=0.35cm,
    minimum height=0.75cm,
    parallelepiped offset x=3mm,
    parallelepiped offset y=2mm,
    xscale=-1,
    path picture={
      \draw[top color=gray!5,bottom color=gray!40]
      (path picture bounding box.south west) rectangle 
      (path picture bounding box.north east);
      \coordinate (A-center) at ($(path picture bounding box.center)!0!(path
        picture bounding box.south)$);
      \coordinate (A-west) at ([xshift=-0.575cm]path picture bounding box.west);
      \draw[ports]([yshift=0.1cm]$(A-west)!0!(A-center)$)
        rectangle +(0.2,0.065);
      \draw[ports]([yshift=0.01cm]$(A-west)!0.085!(A-center)$)
        rectangle +(0.15,0.05);
      \fill[black]([yshift=-0.35cm]$(A-west)!-0.1!(A-center)$)
        rectangle +(0.235,0.0175);
      \fill[black]([yshift=-0.385cm]$(A-west)!-0.1!(A-center)$)
        rectangle +(0.235,0.0175);
      \fill[black]([yshift=-0.42cm]$(A-west)!-0.1!(A-center)$)
        rectangle +(0.235,0.0175);
    }  
  },
}

\usetikzlibrary{calc, shadings, shadows, shapes.arrows}

% Styles for interfaces and edge labels
\tikzset{%
  interface/.style={draw, rectangle, rounded corners, font=\LARGE\sffamily},
  ethernet/.style={interface, fill=yellow!50},% ethernet interface
  serial/.style={interface, fill=green!70},% serial interface
  speed/.style={sloped, anchor=south, font=\large\sffamily},% line speed at edge
  route/.style={draw, shape=single arrow, single arrow head extend=4mm,
    minimum height=1.7cm, minimum width=3mm, white, fill=switch!20,
    drop shadow={opacity=.8, fill=switch}, font=\tiny}% inroute/outroute arrows
}
\newcommand*{\shift}{1.3cm}% For placing the arrows later

% The router icon
\newcommand*{\router}[1]{
\begin{tikzpicture}    
  \coordinate (ll) at (-3,0.5);
  \coordinate (lr) at (3,0.5);
  \coordinate (ul) at (-3,2);
  \coordinate (ur) at (3,2);
  \shade [shading angle=90, left color=switch, right color=white] (ll)
    arc (-180:-60:3cm and .75cm) -- +(0,1.5) arc (-60:-180:3cm and .75cm)
    -- cycle;
  \shade [shading angle=270, right color=switch, left color=white!50] (lr)
    arc (0:-60:3cm and .75cm) -- +(0,1.5) arc (-60:0:3cm and .75cm) -- cycle;
  \draw [thick] (ll) arc (-180:0:3cm and .75cm)
    -- (ur) arc (0:-180:3cm and .75cm) -- cycle;
  \draw [thick, shade, upper left=switch, lower left=switch,
    upper right=switch, lower right=white] (ul)
    arc (-180:180:3cm and .75cm);
  \node at (0,0.5){\color{blue!60!black}\Huge #1};% The name of the router
  % The four arrows, symbols for incoming and outgoing routes:
  \begin{scope}[yshift=2cm, yscale=0.28, transform shape]
    \node[route, rotate=45, xshift=\shift] {\strut};
    \node[route, rotate=-45, xshift=-\shift] {\strut};
    \node[route, rotate=-135, xshift=\shift] {\strut};
    \node[route, rotate=135, xshift=-\shift] {\strut};
  \end{scope}
\end{tikzpicture}}

\makeatletter
\pgfdeclareradialshading[tikz@ball]{cloud}{\pgfpoint{-0.275cm}{0.4cm}}{%
  color(0cm)=(tikz@ball!75!white);
  color(0.1cm)=(tikz@ball!85!white); 
  color(0.2cm)=(tikz@ball!95!white); 
  color(0.7cm)=(tikz@ball!89!black); 
  color(1cm)=(tikz@ball!75!black)
}
\tikzoption{cloud color}{\pgfutil@colorlet{tikz@ball}{#1}%
  \def\tikz@shading{cloud}\tikz@addmode{\tikz@mode@shadetrue}}
\makeatother

\tikzset{my cloud/.style={
     cloud, draw, aspect=2,
     cloud color={gray!5!white}
  }
}
\begin{center}
\begin{tikzpicture}

\node[server](server 1){};
\node[server, right of= server 1](server 2){};
\node[server, right of= server 2](server 3){};

\node[rack switch, above of=server 2,xshift=0.1cm,yshift=0.3cm]
  (rack switch 1){};

\draw[thick,darkgray!10!gray] (server 1.north)--(rack switch 1);
\draw[thick,darkgray!10!gray] (server 2.north)--(rack switch 1);
\draw[thick,darkgray!10!gray] (server 3.north)--(rack switch 1);

\begin{scope}[xshift=3.5cm]
  \node[server](server 4){};
  \node[server, right of= server 4](server 5){};
  \node[server, right of= server 5](server 6){};

  \node[rack switch, above of=server 5,xshift=0.1cm,yshift=0.3cm]
  (rack switch 2){};

  \draw[thick,darkgray!10!gray] (server 4.north)--(rack switch 2);
  \draw[thick,darkgray!10!gray] (server 5.north)--(rack switch 2);
  \draw[thick,darkgray!10!gray] (server 6.north)--(rack switch 2);
\end{scope}

\begin{scope}[xshift=8cm]
  \node[server](server 7){};
  \node[server, right of= server 7](server 8){};
  \node[server, right of= server 8](server 9){};

  \node[rack switch, above of=server 8,xshift=0.1cm,yshift=0.3cm]
  (rack switch 3){};

  \draw[thick,darkgray!10!gray] (server 7.north)--(rack switch 3);
  \draw[thick,darkgray!10!gray] (server 8.north)--(rack switch 3);
  \draw[thick,darkgray!10!gray] (server 9.north)--(rack switch 3);
\end{scope}


\node[l3 switch, above of =rack switch 1, xshift=1.5cm,yshift=0.5cm]
  (l3 switch 1){};
\node[l3 switch, above of =rack switch 2, xshift=2cm,yshift=0.5cm]
  (l3 switch 2){};

\begin{scope}[very thick,darkgray!10!gray]
  \draw ($(rack switch 1.north)!0.5!(rack switch 1.north west)$)--
   ($(l3 switch 2.south)!0.5!(l3 switch 2.south west)$);
  \draw ($(rack switch 1.north)!0.5!(rack switch 1.north east)$)--
   ($(l3 switch 1.south)!0.5!(l3 switch 1.south west)$);

  \draw ($(rack switch 2.north)!0.5!(rack switch 2.north west)$)--
   ($(l3 switch 2.south)!0!(l3 switch 2.south west)$);
  \draw ($(rack switch 2.north)!0.5!(rack switch 2.north east)$)--
   ($(l3 switch 1.south)!0!(l3 switch 1.south west)$);  

  \draw ($(rack switch 3.north)!0.5!(rack switch 3.north west)$)--
   ($(l3 switch 2.south)!0.5!(l3 switch 2.south east)$);
  \draw ($(rack switch 3.north)!0.5!(rack switch 3.north east)$)--
   ($(l3 switch 1.south)!0.5!(l3 switch 1.south east)$); 

  \draw ($(l3 switch 2.north west)!0.25!(l3 switch 2.south west)$)--
  ($(l3 switch 1.north east)!0.25!(l3 switch 1.south east)$);

  \draw ($(l3 switch 2.north west)!0.75!(l3 switch 2.south west)$)--
  ($(l3 switch 1.north east)!0.75!(l3 switch 1.south east)$);

\end{scope} 

\node[l3 switch, above of =l3 switch 1, xshift=2cm,yshift=0.75cm](border 1){}; 

% = = = = = = = = = = = = = = = =
% Labels
% = = = = = = = = = = = = = = = =


\node[xshift=-1.05cm,yshift=0.2cm,left of = server 3,align=left](lev1)
  {User Devices};

\node[xshift=0.9cm,yshift=0.3cm,above of = lev1,align=left](lev2)
  {Access Layer};

\node[xshift=1.6cm,yshift=0.4cm,above of = lev2,align=left](lev3)
  {Aggregation Layer};
\node[xshift=2.55cm,yshift=0.75cm,above of = lev3,align=right](lev4)
  {Core Layer};
\node[xshift=-1cm,yshift=1.2cm,above of = lev4,align=right](lev5)
  {Gateway Router};
\node[xshift=7cm,yshift=0.1cm,above of = lev3,align=right](lev6)
  {Data captured here};
\node[xshift=7cm,yshift=-0.3cm,above of = lev3,align=right](lev7)
  {and analysed};

% = = = = = = = = = = = = = = = =
% Background rectangle - removed
% = = = = = = = = = = = = = = = =

\path ($(server 3.south west)!0.9!(lev1.south east)-(0,0.4cm)$) coordinate (A)
  --([yshift=0.86cm]A |- lev4.north east)coordinate (B)--
  ($(B)+(11.2cm,0)$)coordinate (C);

% = = = = = = = = = = = = = = = =
% Border Router and Internet
% = = = = = = = = = = = = = = = =

% interconnections of border 1
\begin{scope}[very thick,darkgray!10!gray]
  \draw ($(border 1.south)!0.5!(border 1.south west)$)--
   (l3 switch 1.north);

  \draw ($(border 1.south)!-0.5!(border 1.south west)$)--
   (l3 switch 2.north);
\end{scope}

\begin{scope}
  \node[yshift=1cm,xshift=-6cm,scale=0.2] (brouter) at (C) {\router{}}
    edge[very thick,darkgray!10!gray] ([xshift=0.1cm,yshift=0.5cm]border 1);

  \node[yshift=0.65cm,my cloud, minimum width=1.25cm, minimum height=1.55cm,
    above of=brouter,font=\large] (it) {Internet}
      edge[very thick,darkgray!30!gray] (brouter);
\end{scope}

\draw [dashed] (0,2.3) -- (5,2.3);
\draw [dashed] (0,5.3) -- (5,5.3);
\draw [dashed] (0,2.3) -- (0,5.3);
\draw [dashed] (5,2.3) -- (5,5.3);
\draw [->] (5,3.8) -- (7,3.8);
\node[server] at (7.5,3.8){};
\end{tikzpicture}
\figurecaption{用户数据采集及处理}
\end{center}
目前，国内外比较流行使用的网络流量信息采集方式有Cisco公司开发的NetFlow工具。
支持NetFlow的路由器和交换机能够收集所有接口上IP交换数据，并且能把数据导出到NetFlow信息分析服务器上。
国内研究人员也设计了类似的分布式网络流量分析系统\parencite{乔媛媛2014基于,延皓2011基于流量监测的网络用户行为分析,董超2013基于网络流量监测的移动互联网特征研究}。

本文根据NetFlow采集模式设计采集及处理模块。
对于每个地区的路由器或者交换机，都连接到信息分析服务器。
信息分析服务器将过滤Content-Type不是HTML类型的文件，比如js和css文件，然后记录如下信息。
\begin{center}
\tablecaption{信息分析服务器记录信息格式}
\begin{tabular}{c|c|c|c|c|c}
	\hline
	User ID & Request URL & Time & Location & Content & Device \\
	\hline
\end{tabular}
\end{center}

对于以上信息，本模块主要分析Request URL与HTML文件。
由于URL包含网站名称，以及访问路径，故URL包含部分关键词。
可将URL作为一个语句进行语义分析。
另外，由于HTML文件结构可知，其中的内容镶嵌在各种HTML标签中。
故分析HTML文件首先要去除各种标签。
通过实现监督学习算法\parencite{Kohlsch2010Boilerplate}去除标签，将剩下的文字内容输入语义分析模块。

按照第二章第一节描述的语义分析原理，本模块首先分析得出所有关键词。
从关键词中取出所有名词，并按照出现次数进行排序。
将高频名词按照以下格式输出保存。
\begin{center}
\tablecaption{信息分析服务器输出信息格式}
\begin{tabular}{c|c|c|c|c|c}
	\hline
	User ID & Request URL & Time & Location & Item & Device \\
	\hline
\end{tabular}
\end{center}
\section{基于大数据处理的推荐算法}
根据Hadoop与MapReduce的原理及特点，我们可以将协同过滤算法计算过程分解到Map阶段与Reduce阶段中。

首先要进行简单的计数工作，即计算每个User-Item对的数目。
将该数目代入逻辑函数$S(t)=1/(1+e^{-t})$进行简单的归一化。
得到User-Item-Value格式的一组数据，形成下一步所需的User-Item矩阵，记为$R=\{<i,j,r_{i,j}>\}$，保存于Hadoop的HDFS中。
以下假设$n$个用户，$m$个物品，

\subsection{计算每个用户的平均评分}
每个用户$i$的平均评分可以如下计算：
\[
\bar{r_i} = \frac{\sum_{j=1}^n r_{i,j}}{\sum_{k=1}^l 1}\qquad \forall i\in [1,n]
\]
其中$l$表示该用户评价了几个物品。

生成的平均评分数据集记为$U_{all}=\{<i,\bar{r}_i>\},\forall i\in [1,n]$。具体的Map与Reduce算法如下：
\begin{description}
\item[Map-I:] 将$i$相同的$<i,j,r_{i,j}>$映射到同一个机器中，简记为$<j,r_{i,j}>$。对于$k$个机器，本步骤的复杂度为$o(\frac{nm}{k})$。
\item[Reduce-I:] 取出$<i,j,r_{i,j},\bar{r}_i>$，保存到HDFS中，此时将$R$指向$\{<i,j,r_{i,j},\bar{r}_i>\}$。另外保存$U_{all}=\{<i,\bar{r}_i>\},\forall i\in [1,n]$到HDFS中。本步骤的复杂度同样为$o(\frac{nm}{k})$。
\end{description}

\subsection{计算用户间相似度}
计算用户间相似度矩阵$S={S_{i,j}|\forall i,j\in[1,n]}$。
定义$U_i = \{<i,j,r_{i,j},\bar{r}_i>|\forall j \in [1,m],<i,j,r_{i,j},\bar{r}_i>\in R\}$为用户$i$评价过的物品集。
定义$N_{k,l} = U_k \cap U_l$，为用户$k$与用户$l$共同评价过的物品集。
为了计算可行性，$N_{k,l}$将分到同一个节点上。具体的Map与Reduce算法如下：
\begin{description}
\item[Map-II:] 将$\{U_i|i\in [1,n]\}$映射为$\{N_i,j|\forall i,j\in [1,n]\}$。如果有$k$个机器，本步骤的复杂度为$o(\frac{m^2n}{k})$。
\item[Reduce-II:] 取出$\{S_{i,j}|\forall i,j\in [1,n]\}$，保存到HDFS中。本步骤的复杂度为$o(\frac{m^2n}{k})$。
\end{description}
此步骤可以看出可以看出，对于物品数远大于用户数的情况，本算法更适合于用户数远大于物品数的情况。

\subsection{计算预测矩阵}
将矩阵$R$变形为矩阵$I$，其中矩阵$I$的数据按物品的序号排序：
\begin{equation}
I=\left(
\begin{array}{c}
I_1 \\
I_2 \\
\vdots \\
I_m
\end{array}
\right) = \{I_j|\forall j\in [1,m] \}
\end{equation}
其中
\begin{equation}
I_j=\left(
\begin{array}{c}
<1,j,r_{1,j},\bar{r}_1 > \\
<2,j,r_{2,j},\bar{r}_2 > \\
\vdots \\
<n,j,r_{n,j},\bar{r}_n >
\end{array}
\right) = \{<i,j,r_{i,j},\bar{r}_i >|\forall i\in [1,n], <i,j,r_{i,j},\bar{r}_i > \in R\}
\end{equation}
即$I_j$表示与物品$j$相关的所有评分数据集。
定义相似度矩阵$S$为
\begin{equation}
S=\left(
\begin{array}{ccc}
S_{1,1} & \ldots & S_{1,n} \\
\vdots & \vdots & \vdots \\
S_{n,1} & \ldots & S_{n,n} \\
\end{array}
\right) = \left(
\begin{array}{c}
S_1 \\
\vdots\\
S_n
\end{array}
\right)
\end{equation}
其中$S_i=\{S_{i,j}|\forall j\in [1,n] \}$表示用户$i$与其它用户间的相似度。
具体的Map与Reduce算法如下：
\begin{description}
\item[Map-III:] 将$j$相同的$<i,j,r_{i,j}>$映射到同一个机器中，简记为$<j,r_{i,j}>$，同时将$S_i$映射到同一个机器中。对于$k$个机器，本步骤的复杂度为$o(\frac{nm}{k})$。
\item[Reduce-III:] 取出$B=<i,j,r_{i,j},\bar{r}_i ,S_i>$，保存到HDFS中。本步骤的复杂度为$o(\frac{m^2n}{k})$。
\end{description}
这一步是为计算预测矩阵做准备。按照第二章的公式计算用户$i$对物品$j$的评分$p_{i,j}$。预测矩阵$P$定义为：
\begin{equation}
P=\left(
\begin{array}{c}
 \{ p_{1,1},p_{1,3},p_{1,5} \} \\
\vdots \\
\{ p_{i,1},p_{i,3},p_{i,5} \} \\
\vdots \\
\{p_{n,1},p_{n,3},p_{n,5}\}
\end{array}
\right) = \left(
\begin{array}{c}
P_1 \\
\vdots\\
P_i\\
\vdots \\
P_n
\end{array}
\right)
\end{equation}
其中$P_i=\{p_{i,j}|\forall j\in [1,m],<i,j,r_{i,j},\bar{r}_i>\notin R\},\forall i\in[1,n]$表示用户$i$对未评价物品集的所有预测分数。
具体的Map与Reduce算法如下：
\begin{description}
\item[Map-IV:] 将$i$相同的$B=<i,j,r_{i,j},\bar{r}_i ,S_i>$映射到同一个机器中，简记为$<j,r_{i,j},\bar{r}_i ,S_i>$，同时将Map-I生成的$U_{all}$中的$U_i$映射到同一个机器中。对于$k$个机器，本步骤的复杂度为$o(\frac{nm}{k})$。将
\item[Reduce-IV:] 取出$P=<i,j,p_{i,j},>$，保存到HDFS中。本步骤的复杂度为$o(\frac{m^2n}{k})$。
\end{description}
至此所有用户对未评价物品集的分数$p_{i,j}$都已经计算出来。
即构建了完整的User-Item矩阵，也即用户兴趣模型。
此时对于每个用户，对所有物品按评价分数大小排序，排名前k的物品组成一个向量。
下一步可以根据这个向量推荐用户内容。






